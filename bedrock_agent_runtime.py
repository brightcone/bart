import logging
import boto3
from botocore.exceptions import ClientError

# Set up logging to display debug information
logging.basicConfig(level=logging.DEBUG)

def invoke_agent(agent_id, agent_alias_id, session_id, prompt):
    """
    Invokes an Amazon Bedrock agent to process a given prompt and returns the output, citations, and trace information.

    Parameters:
        agent_id (str): The unique identifier of the Bedrock agent to invoke.
        agent_alias_id (str): The alias ID of the Bedrock agent version to be used.
        session_id (str): A unique session identifier for tracking and managing the agent invocation.
        prompt (str): The input text or query to be processed by the agent.

    Returns:
        dict: A dictionary containing:
            - output_text (str): The concatenated output text generated by the agent.
            - citations (list): A list of citations related to the agent's output.
            - trace (dict): A dictionary containing trace information, including pre-processing, orchestration, and post-processing details.

    Raises:
        ClientError: If an error occurs while invoking the agent or communicating with the AWS service.

    Example:
        >>> response = invoke_agent(
                agent_id="agent-1234",
                agent_alias_id="alias-5678",
                session_id="session-91011",
                prompt="What is the weather today?"
            )
        >>> print(response["output_text"])
    """
    
    try:
        # Create a client for the Bedrock Agent Runtime service using the default session
        client = boto3.session.Session().client(service_name="bedrock-agent-runtime")
        
        # Invoke the Bedrock agent with the specified parameters
        response = client.invoke_agent(
            agentId=agent_id,         # The unique identifier for the agent
            agentAliasId=agent_alias_id,  # The alias ID of the agent's version to use
            enableTrace=True,         # Enable tracing to get detailed processing information
            sessionId=session_id,     # A unique identifier for this session
            inputText=prompt,         # The prompt or query to be processed by the agent
        )
        
        # Initialize variables to store the output text, citations, and trace information
        output_text = ""
        citations = []
        trace = {}

        # Process the completion events in the response
        for event in response.get("completion", []):
            # Combine the chunks to get the output text
            if "chunk" in event:
                chunk = event["chunk"]
                output_text += chunk["bytes"].decode()  # Concatenate the decoded bytes to the output text
                # Collect any citations related to this chunk
                if "attribution" in chunk:
                    citations.extend(chunk["attribution"]["citations"])

            # Extract trace information from all events
            if "trace" in event:
                # Look for specific types of trace information
                for trace_type in ["preProcessingTrace", "orchestrationTrace", "postProcessingTrace"]:
                    # If trace information of this type is present, add it to the trace dictionary
                    if trace_type in event["trace"]["trace"]:
                        if trace_type not in trace:
                            trace[trace_type] = []
                        trace[trace_type].append(event["trace"]["trace"][trace_type])

    # Handle any client errors that occur during the process
    except ClientError as e:
        # Log the error with a message
        logging.error(f"An error occurred: {e}")
        # Raise the error to signal that an exception has occurred
        raise

    # Return a dictionary with the output text, citations, and trace information
    return {
        "output_text": output_text,
        "citations": citations,
        "trace": trace
    }
